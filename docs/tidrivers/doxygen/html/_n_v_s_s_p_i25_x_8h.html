<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>NVSSPI25X.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_3b541eea6259595923e49fb49c6b8bf6.html">tidrivers_cc13xx_cc26xx_3_30_03_00</a></li><li class="navelem"><a class="el" href="dir_79a6a61e2229792d5e8f66f7bdbf7543.html">source</a></li><li class="navelem"><a class="el" href="dir_a0a008e4586023d1120bd251d0c07733.html">ti</a></li><li class="navelem"><a class="el" href="dir_d0671196ce735ce071f605df95eeb992.html">drivers</a></li><li class="navelem"><a class="el" href="dir_94a8c0941d4c402501175ec2a70f8299.html">nvs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">NVSSPI25X.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Non-Volatile Storage driver implementation for SPI flash peripherals. </p>
<hr/>
<h1>Overview</h1>
<p>The NVSSPI25X module allows you to manage SPI flash memory. This driver works with most 256 byte/page SPI flash memory devices such as: </p><pre class="fragment">Winbond     W25xx   family
Macronics   MX25Rxx family
Micron      N25Qxx  family
</pre><p>The SPI flash commands used by this driver are as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SPIFLASH_PAGE_WRITE       0x02 // Page Program (up to 256 bytes)</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_READ             0x03 // Read Data</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_READ_STATUS      0x05 // Read Status Register</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_WRITE_ENABLE     0x06 // Write Enable</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_SUBSECTOR_ERASE  0x20 // SubSector (4K bytes) Erase</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_SECTOR_ERASE     0xD8 // Sector (usually 64K bytes) Erase</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_RDP              0xAB // Release from Deep Power Down</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_DP               0xB9 // Deep Power Down</span></div><div class="line"><span class="preprocessor">#define SPIFLASH_MASS_ERASE       0xC7 // Erase entire flash.</span></div></div><!-- fragment --><p>It is assumed that the SPI flash device used by this driver supports the byte programmability of the SPIFLASH_PAGE_WRITE command and that write page size is 256 bytes.</p>
<p>The <a class="el" href="_n_v_s_8h.html#a4f309d160ac4641c89501adc95d170b3" title="Erase &#39;size&#39; bytes of the region beginning at &#39;offset&#39; bytes from the base of the region referenced b...">NVS_erase()</a> command assumes that regions with sectorSize = 4096 bytes are erased using the SPIFLASH_SUBSECTOR_ERASE command (0x20). Otherwise the SPIFLASH_SECTOR_ERASE command (0xD8) is used to erase the flash sector. It is up to the user to ensure that each region's sectorSize matches these sector erase rules.</p>
<p>For each managed flash region, a corresponding SPI instance must be provided to the NVSSPI25X driver. As well, a GPIO instance index must be provided to the driver so that the SPI flash device's chip select can be asserted during SPI transfers.</p>
<p>The SPI instance can be opened and closed internally by the NVSSPI25X driver, or alternatively, a SPI handle can be provided to the NVSSPI25X driver, indicating that the SPI instance is being opened and closed elsewhere within the application. This mode is useful when the SPI bus is share by more than just the SPI flash device.</p>
<p>If the SPI instance is to be managed internally by the NVSSPI25X driver, a SPI instance index and bit rate must be configured in the region's HWAttrs. If the same SPI instance is referenced by multiple flash regions the driver will ensure that <a class="el" href="_s_p_i_8h.html#a9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> is invoked only once, and that <a class="el" href="_s_p_i_8h.html#a0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a> will only be invoked when all flash regions using the SPI instance have been closed.</p>
<p>If the SPI bus that the SPI flash device is on is shared with other devices accessed by an application, then the SPI handle used to manage a SPI flash region can be provided in the region's HWAttrs "spiHandle" field. Keep in mind that the "spiHandle" field is a POINTER to a SPI Handle, NOT a SPI Handle. This allows the user to simply initialize this field with the name of the global variable used for the SPI handle. In this mode, the user MUST open the SPI instance prior to opening the NVS region instance so that the referenced spiHandle is valid.</p>
<p>By default, the "spiHandle" field is set to NULL, indicating that the user expects the NVS driver to open and close the SPI instance internally using the 'spiIndex' and 'spiBitRate' provided in the HWAttrs.</p>
<p>Regardless of whether a region's SPI instance is opened by the driver or elsewhere within the application, the GPIO instance used to select the SPI flash device during SPI operations MUST be provided. The GPIO pin will be configured as "GPIO_CFG_OUT_STD" and assertion of this pin is assumed to be active LOW. </p>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_s_p_i_8h_source.html">ti/drivers/SPI.h</a>&gt;</code><br />
</div>
<p><a href="_n_v_s_s_p_i25_x_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_v_s_s_p_i25_x___h_w_attrs.html">NVSSPI25X_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVSSPI25X attributes.  <a href="struct_n_v_s_s_p_i25_x___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_v_s_s_p_i25_x___object.html">NVSSPI25X_Object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a89a4a07b7be073b897feebf4760f1662"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_s_p_i25_x_8h.html#a89a4a07b7be073b897feebf4760f1662">NVSSPI25X_CMD_MASS_ERASE</a>&#160;&#160;&#160;(<a class="el" href="group___n_v_s___c_o_n_t_r_o_l.html#gaa9fa1c41660d17139bce63ff34cd774f">NVS_CMD_RESERVED</a> + 0)</td></tr>
<tr class="memdesc:a89a4a07b7be073b897feebf4760f1662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to perform mass erase of entire flash.  <a href="#a89a4a07b7be073b897feebf4760f1662">More...</a><br /></td></tr>
<tr class="separator:a89a4a07b7be073b897feebf4760f1662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aebd6500a16f6e85681ba7e5c000d0156"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_n_v_s_s_p_i25_x___h_w_attrs.html">NVSSPI25X_HWAttrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_s_p_i25_x_8h.html#aebd6500a16f6e85681ba7e5c000d0156">NVSSPI25X_HWAttrs</a></td></tr>
<tr class="memdesc:aebd6500a16f6e85681ba7e5c000d0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVSSPI25X attributes.  <a href="#aebd6500a16f6e85681ba7e5c000d0156">More...</a><br /></td></tr>
<tr class="separator:aebd6500a16f6e85681ba7e5c000d0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817f992b570e02d68f89bcabbe2ae856"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_n_v_s_s_p_i25_x___object.html">NVSSPI25X_Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_s_p_i25_x_8h.html#a817f992b570e02d68f89bcabbe2ae856">NVSSPI25X_Object</a></td></tr>
<tr class="separator:a817f992b570e02d68f89bcabbe2ae856"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a105e78ab0c157b8ad847af271b05b18c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_s___fxn_table.html">NVS_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_s_p_i25_x_8h.html#a105e78ab0c157b8ad847af271b05b18c">NVSSPI25X_fxnTable</a></td></tr>
<tr class="separator:a105e78ab0c157b8ad847af271b05b18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a89a4a07b7be073b897feebf4760f1662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a4a07b7be073b897feebf4760f1662">&sect;&nbsp;</a></span>NVSSPI25X_CMD_MASS_ERASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVSSPI25X_CMD_MASS_ERASE&#160;&#160;&#160;(<a class="el" href="group___n_v_s___c_o_n_t_r_o_l.html#gaa9fa1c41660d17139bce63ff34cd774f">NVS_CMD_RESERVED</a> + 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Command to perform mass erase of entire flash. </p>
<p>As this command can erase flash memory outside the region associated with the NVS_Handle passed to the control command, the user must carefully orchestrate the use of the command.</p>
<p>Mass Erase is the only control command supported. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aebd6500a16f6e85681ba7e5c000d0156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd6500a16f6e85681ba7e5c000d0156">&sect;&nbsp;</a></span>NVSSPI25X_HWAttrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_n_v_s_s_p_i25_x___h_w_attrs.html">NVSSPI25X_HWAttrs</a>  <a class="el" href="struct_n_v_s_s_p_i25_x___h_w_attrs.html">NVSSPI25X_HWAttrs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVSSPI25X attributes. </p>
<p>The 'regionBaseOffset' is the offset, in bytes, from the base of the SPI flash, of the flash region to be managed.</p>
<p>The 'regionSize' must be an integer multiple of the flash sector size.</p>
<p>The 'sectorSize' is SPI flash device specific. This parameter should correspond to the number of bytes erased when the 'SPIFLASH_SUBSECTOR_ERASE' (0x20) command is issued to the device.</p>
<p>The 'verifyBuf' and 'verifyBufSize' parameters are used by the <a class="el" href="_n_v_s_8h.html#aae7abe0cb889a6d0cc1858bfc69ab7e0" title="Write data to an NVS region. ">NVS_write()</a> command when either 'NVS_WRITE_PRE_VERIFY' or 'NVS_WRITE_POST_VERIFY' functions are requested in the 'flags' argument. The 'verifyBuf' is used to successively read back portions of the flash to compare with the data being written to it.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Only one region write operation is performed at a time</span></div><div class="line"><span class="comment">// so a single verifyBuf can be shared by all the regions.</span></div><div class="line"><span class="comment">//</span></div><div class="line">uint8_t verifyBuf[256];</div><div class="line"></div><div class="line"><a class="code" href="struct_n_v_s_s_p_i25_x___h_w_attrs.html">NVSSPI25X_HWAttrs</a> nvsSPIHWAttrs[2] = {</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// region 0 is 1 flash sector in length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        .<a class="code" href="struct_n_v_s_s_p_i25_x___h_w_attrs.html#a0743a03845422aebdcc49c67552637cb">regionBaseOffset</a> = 0,</div><div class="line">        .regionSize = 4096,</div><div class="line">        .sectorSize = 4096,</div><div class="line">        .verifyBuf = verifyBuf;</div><div class="line">        .verifyBufSize = 256;</div><div class="line">        .spiHandle = NULL,</div><div class="line">        .spiIndex = 0,</div><div class="line">        .spiBitRate = 40000000,</div><div class="line">        .spiCsGpioIndex = 12,</div><div class="line">    },</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// region 1 is 3 flash sectors in length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        .regionBaseOffset = 4096,</div><div class="line">        .regionSize = 4096 * 3,</div><div class="line">        .sectorSize = 4096,</div><div class="line">        .verifyBuf = verifyBuf;     <span class="comment">// use shared verifyBuf</span></div><div class="line">        .verifyBufSize = 256;</div><div class="line">        .spiHandle = NULL,</div><div class="line">        .spiIndex = 0,</div><div class="line">        .spiBitRate = 40000000,</div><div class="line">        .spiCsGpioIndex = 12,</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> 
</div>
</div>
<a id="a817f992b570e02d68f89bcabbe2ae856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817f992b570e02d68f89bcabbe2ae856">&sect;&nbsp;</a></span>NVSSPI25X_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_n_v_s_s_p_i25_x___object.html">NVSSPI25X_Object</a>  <a class="el" href="struct_n_v_s_s_p_i25_x___object.html">NVSSPI25X_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a105e78ab0c157b8ad847af271b05b18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105e78ab0c157b8ad847af271b05b18c">&sect;&nbsp;</a></span>NVSSPI25X_fxnTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_s___fxn_table.html">NVS_FxnTable</a> NVSSPI25X_fxnTable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2017, Texas Instruments Incorporated
</small>
</body>
</html>
